import mongoose from 'mongoose';
import { validateDateTime, getDefaultTimezone } from '../utils/timezone.js';

const tripSchema = new mongoose.Schema({
  tripId: {
    type: String,
    unique: true,
    required: true  // Generated by pre-validate middleware
  },
  // Trip details
  rider: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  riderName: {
    type: String,
    required: true,
    trim: true
  },
  riderPhone: {
    type: String,
    trim: true
  },
  riderEmail: {
    type: String,
    trim: true,
    lowercase: true
  },
  
  // Locations
  pickupLocation: {
    address: { type: String, required: true },
    lat: { type: Number, required: true },
    lng: { type: Number, required: true },
    notes: String
  },
  dropoffLocation: {
    address: { type: String, required: true },
    lat: { type: Number, required: true },
    lng: { type: Number, required: true },
    notes: String
  },
  
  // Scheduling
  scheduledDate: {
    type: Date,
    required: true
  },
  scheduledTime: {
    type: String,
    required: true,
    validate: {
      validator: function(v) {
        // Validate HH:MM format
        return /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/.test(v);
      },
      message: props => `${props.value} is not a valid time format. Use HH:MM (24-hour format).`
    }
  },
  timezone: {
    type: String,
    default: getDefaultTimezone,
    validate: {
      validator: function(v) {
        // Basic timezone validation (IANA format)
        try {
          Intl.DateTimeFormat(undefined, { timeZone: v });
          return true;
        } catch (e) {
          return false;
        }
      },
      message: props => `${props.value} is not a valid timezone identifier.`
    }
  },
  estimatedDuration: {
    type: Number // in minutes
  },
  estimatedDistance: {
    type: Number // in kilometers
  },
  
  // Assignment
  assignedDriver: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  vehicle: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Vehicle'
  },
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  
  // Status tracking
  status: {
    type: String,
    enum: ['pending', 'assigned', 'in_progress', 'completed', 'cancelled'],
    default: 'pending'
  },
  
  // Status history for audit trail and reversion
  statusHistory: [{
    status: {
      type: String,
      enum: ['pending', 'assigned', 'in_progress', 'completed', 'cancelled'],
      required: true
    },
    changedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true
    },
    changedAt: {
      type: Date,
      default: Date.now,
      required: true
    },
    reason: String, // For cancellations or special circumstances
    metadata: mongoose.Schema.Types.Mixed // Additional context
  }],
  
  // Time tracking
  actualPickupTime: Date,
  actualDropoffTime: Date,
  
  // Additional information
  tripType: {
    type: String,
    enum: ['regular', 'medical', 'urgent', 'recurring'],
    default: 'regular'
  },
  specialInstructions: String,
  
  // Recurring trip information
  isRecurring: {
    type: Boolean,
    default: false
  },
  recurringPattern: {
    frequency: {
      type: String,
      enum: ['daily', 'weekly', 'biweekly', 'monthly', 'custom']
    },
    daysOfWeek: [Number], // 0-6 (Sunday-Saturday)
    weekOfMonth: Number, // 1-4 for specific week of month
    interval: Number, // Every N days/weeks/months
    endDate: Date,
    endAfterOccurrences: Number, // Alternative to endDate
    isIndefinite: {
      type: Boolean,
      default: false
    },
    customPattern: String // For complex patterns like "every other Tuesday"
  },
  parentTripId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Trip'
  },
  childTripIds: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Trip'
  }],
  
  // Driver updates
  driverNotes: String,
  driverLocation: {
    lat: Number,
    lng: Number,
    lastUpdated: Date
  },
  
  // Trip metrics (collected during drive mode)
  tripMetrics: {
    completionTime: Date,
    startTime: Date,
    durationMinutes: Number,
    distanceTraveled: Number, // in miles
    averageSpeed: Number, // mph
    finalLocation: {
      latitude: Number,
      longitude: Number,
      accuracy: Number,
      timestamp: Date
    },
    finalHeading: Number,
    cancellationReason: String
  },
  
  // GPS Route Tracking - Actual path taken by driver
  routeTracking: {
    isEnabled: {
      type: Boolean,
      default: true
    },
    routePoints: [{
      latitude: {
        type: Number,
        required: true
      },
      longitude: {
        type: Number,
        required: true
      },
      timestamp: {
        type: Date,
        required: true,
        default: Date.now
      },
      accuracy: Number, // in meters
      altitude: Number, // in meters
      speed: Number, // in m/s
      heading: Number, // in degrees (0-360)
      batteryLevel: Number, // percentage (0-100)
      isSignificant: {
        type: Boolean,
        default: false // marks important waypoints
      }
    }],
    routeSummary: {
      totalPoints: {
        type: Number,
        default: 0
      },
      totalDistance: {
        type: Number,
        default: 0 // in kilometers
      },
      actualDuration: {
        type: Number,
        default: 0 // in minutes
      },
      startTime: Date,
      endTime: Date,
      averageSpeed: Number, // km/h
      maxSpeed: Number, // km/h
      idleTime: Number, // in minutes
      movingTime: Number // in minutes
    },
    deviations: [{
      timestamp: Date,
      location: {
        latitude: Number,
        longitude: Number
      },
      distanceFromPlanned: Number, // in meters
      reason: String,
      duration: Number // how long the deviation lasted in minutes
    }],
    geofenceEvents: [{
      eventType: {
        type: String,
        enum: ['pickup_zone_entered', 'pickup_zone_exited', 'dropoff_zone_entered', 'dropoff_zone_exited', 'route_boundary_exceeded']
      },
      timestamp: Date,
      location: {
        latitude: Number,
        longitude: Number
      }
    }]
  },
  
  // Rating and feedback
  rating: {
    type: Number,
    min: 1,
    max: 5
  },
  feedback: String,
  
  // Cost information
  estimatedCost: Number,
  actualCost: Number,
  
  // Cancellation
  cancellationReason: String,
  cancelledBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  cancelledAt: Date
}, {
  timestamps: true
});

// Generate unique 8-character trip ID before validation
tripSchema.pre('validate', function(next) {
  if (!this.tripId) {
    // Generate 8-character alphanumeric ID
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let tripId = '';
    for (let i = 0; i < 8; i++) {
      tripId += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    this.tripId = tripId;
  }
  
  // Validate date/time combination
  if (this.scheduledDate && this.scheduledTime) {
    const dateStr = this.scheduledDate.toISOString().split('T')[0];
    const validation = validateDateTime(dateStr, this.scheduledTime);
    if (!validation.isValid) {
      return next(new Error(`Invalid date/time: ${validation.errors.join(', ')}`));
    }
  }
  
  next();
});

// Index for efficient queries
tripSchema.index({ assignedDriver: 1, status: 1 });
tripSchema.index({ scheduledDate: 1 });
tripSchema.index({ createdBy: 1 });
// tripId index created automatically by unique: true

export default mongoose.model('Trip', tripSchema);