import Trip from '../models/Trip.js';

class RecurringTripService {
  static generateRecurringTrips(parentTrip, endDate = null, maxOccurrences = 52) {
    const trips = [];
    const pattern = parentTrip.recurringPattern;
    let currentDate = new Date(parentTrip.scheduledDate);
    let occurrenceCount = 0;

    // Determine end condition
    const shouldEnd = (date, count) => {
      if (pattern.isIndefinite) return false;
      if (pattern.endAfterOccurrences && count >= pattern.endAfterOccurrences) return true;
      if (pattern.endDate && date > new Date(pattern.endDate)) return true;
      if (endDate && date > endDate) return true;
      return count >= maxOccurrences; // Safety limit
    };

    while (!shouldEnd(currentDate, occurrenceCount)) {
      // Skip the first occurrence (original trip)
      if (occurrenceCount > 0) {
        const newTrip = this.createTripFromParent(parentTrip, currentDate);
        trips.push(newTrip);
      }

      currentDate = this.getNextOccurrence(currentDate, pattern);
      occurrenceCount++;
    }

    return trips;
  }

  static createTripFromParent(parentTrip, scheduledDate) {
    const tripData = {
      ...parentTrip.toObject(),
      _id: undefined,
      tripId: undefined, // Will be generated by pre-validate middleware
      scheduledDate: scheduledDate,
      parentTripId: parentTrip._id,
      status: 'pending',
      assignedDriver: null,
      isRecurring: false, // Child trips are not recurring themselves
      recurringPattern: undefined,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    delete tripData.__v;
    return new Trip(tripData);
  }

  static getNextOccurrence(currentDate, pattern) {
    const nextDate = new Date(currentDate);

    switch (pattern.frequency) {
      case 'daily':
        nextDate.setDate(nextDate.getDate() + (pattern.interval || 1));
        break;

      case 'weekly':
        if (pattern.daysOfWeek && pattern.daysOfWeek.length > 0) {
          // Find next occurrence based on days of week
          const today = nextDate.getDay();
          const sortedDays = [...pattern.daysOfWeek].sort((a, b) => a - b);
          
          let nextDay = sortedDays.find(day => day > today);
          if (!nextDay) {
            // Move to next week, first day
            nextDay = sortedDays[0];
            nextDate.setDate(nextDate.getDate() + (7 - today + nextDay));
          } else {
            nextDate.setDate(nextDate.getDate() + (nextDay - today));
          }

          // Apply interval (every N weeks)
          if (pattern.interval > 1) {
            nextDate.setDate(nextDate.getDate() + (pattern.interval - 1) * 7);
          }
        } else {
          nextDate.setDate(nextDate.getDate() + 7 * (pattern.interval || 1));
        }
        break;

      case 'biweekly':
        nextDate.setDate(nextDate.getDate() + 14);
        break;

      case 'monthly':
        nextDate.setMonth(nextDate.getMonth() + (pattern.interval || 1));
        break;

      case 'custom':
        // Handle custom patterns
        nextDate.setDate(nextDate.getDate() + this.parseCustomPattern(pattern.customPattern));
        break;

      default:
        nextDate.setDate(nextDate.getDate() + 1);
    }

    return nextDate;
  }

  static parseCustomPattern(customPattern) {
    // Parse patterns like "every other Tuesday", "every 3rd Monday", etc.
    // This is a simplified implementation - can be expanded
    if (customPattern.includes('other')) {
      return 14; // Every other week
    }
    return 7; // Default to weekly
  }

  static async createRecurringTrip(tripData, userId) {
    try {
      // Create parent trip
      const parentTrip = new Trip({
        ...tripData,
        createdBy: userId,
        isRecurring: true,
        tripType: 'recurring'
      });

      await parentTrip.save();

      // Generate child trips
      const childTrips = this.generateRecurringTrips(parentTrip);
      
      if (childTrips.length > 0) {
        // Save child trips
        const savedChildTrips = await Trip.insertMany(childTrips);
        
        // Update parent with child trip IDs
        parentTrip.childTripIds = savedChildTrips.map(trip => trip._id);
        await parentTrip.save();
      }

      return {
        parentTrip,
        childTripsCount: childTrips.length,
        message: `Created recurring trip with ${childTrips.length} future occurrences`
      };
    } catch (error) {
      throw new Error(`Failed to create recurring trip: ${error.message}`);
    }
  }

  static async updateRecurringTrip(parentTripId, updateData) {
    try {
      const parentTrip = await Trip.findById(parentTripId);
      if (!parentTrip || !parentTrip.isRecurring) {
        throw new Error('Parent trip not found or not a recurring trip');
      }

      // Update parent trip
      Object.assign(parentTrip, updateData);
      await parentTrip.save();

      // If pattern changed, regenerate child trips
      if (updateData.recurringPattern) {
        // Delete existing child trips that haven't started
        await Trip.deleteMany({
          parentTripId: parentTripId,
          status: 'pending'
        });

        // Generate new child trips
        const childTrips = this.generateRecurringTrips(parentTrip);
        if (childTrips.length > 0) {
          const savedChildTrips = await Trip.insertMany(childTrips);
          parentTrip.childTripIds = savedChildTrips.map(trip => trip._id);
          await parentTrip.save();
        }
      }

      return parentTrip;
    } catch (error) {
      throw new Error(`Failed to update recurring trip: ${error.message}`);
    }
  }

  static async cancelRecurringTrip(parentTripId, cancelFutureTrips = true) {
    try {
      const parentTrip = await Trip.findById(parentTripId);
      if (!parentTrip) {
        throw new Error('Parent trip not found');
      }

      // Cancel parent trip
      parentTrip.status = 'cancelled';
      parentTrip.cancelledAt = new Date();
      await parentTrip.save();

      if (cancelFutureTrips) {
        // Cancel all pending child trips
        await Trip.updateMany(
          { 
            parentTripId: parentTripId,
            status: 'pending'
          },
          { 
            status: 'cancelled',
            cancelledAt: new Date(),
            cancellationReason: 'Parent recurring trip cancelled'
          }
        );
      }

      return parentTrip;
    } catch (error) {
      throw new Error(`Failed to cancel recurring trip: ${error.message}`);
    }
  }

  static getRecurringPatternDescription(pattern) {
    if (!pattern) return 'One-time trip';

    let description = '';

    switch (pattern.frequency) {
      case 'daily':
        description = pattern.interval > 1 ? `Every ${pattern.interval} days` : 'Daily';
        break;

      case 'weekly':
        if (pattern.daysOfWeek && pattern.daysOfWeek.length > 0) {
          const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
          const days = pattern.daysOfWeek.map(day => dayNames[day]).join(', ');
          description = pattern.interval > 1 ? `Every ${pattern.interval} weeks on ${days}` : `Weekly on ${days}`;
        } else {
          description = pattern.interval > 1 ? `Every ${pattern.interval} weeks` : 'Weekly';
        }
        break;

      case 'biweekly':
        description = 'Every other week';
        break;

      case 'monthly':
        description = pattern.interval > 1 ? `Every ${pattern.interval} months` : 'Monthly';
        break;

      case 'custom':
        description = pattern.customPattern || 'Custom pattern';
        break;

      default:
        description = 'Custom schedule';
    }

    if (pattern.isIndefinite) {
      description += ' (indefinitely)';
    } else if (pattern.endDate) {
      description += ` until ${new Date(pattern.endDate).toLocaleDateString()}`;
    } else if (pattern.endAfterOccurrences) {
      description += ` for ${pattern.endAfterOccurrences} occurrences`;
    }

    return description;
  }
}

export default RecurringTripService;